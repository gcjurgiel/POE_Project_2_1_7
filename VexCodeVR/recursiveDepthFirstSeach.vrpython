{"mode":"Text","textContent":"# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vexcode import *\n\n# math for sine and cosine\nimport math\n\n\nvisited = []\n\n# Initilize all spots to not visited\ndef initilizeMaze():\n    for i in range (0, 8):\n        row = []\n        for j in range (0, 8):\n            row.append(True)\n        visited.append(row)\n\n# cheak is the square at the given angle has been visited\ndef checkVisited(angle):\n    x = round(((location.position(X, MM) - 125)/250) + 4)\n    y = round(((location.position(Y, MM) - 125)/250) + 4)\n\n    dx = round(math.sin(angle * (math.pi/180)))\n    dy = round(math.cos(angle * (math.pi/180)))\n\n    return visited[x + dx][y + dy]\n\n# Set the current space as visited\ndef setVisited():\n    x = round(((location.position(X, MM) - 125)/250) + 4)\n    y = round(((location.position(Y, MM) - 125)/250) + 4)\n\n    visited[x][y] = False\n\n# Recusive methos to solve the maze\ndef solveMaze(angle = 0):\n    \n    # Set the current square to vsited\n    setVisited()\n\n    # Check is the maze has been solved\n    if down_eye.detect(RED):\n        return\n\n    # Check if the forward path is availble\n    drivetrain.turn_to_heading(angle, DEGREES)\n    if (distance.get_distance(MM) > 100) and bool(checkVisited(angle)):\n        # drive to the open space, and recursivly call the method again\n        drivetrain.drive_for(FORWARD, 250, MM);\n        solveMaze(angle)\n    \n    # Check is the maze has been solved\n    if down_eye.detect(RED):\n        return\n\n    # Check if the right path is availble\n    drivetrain.turn_to_heading(angle + 90, DEGREES)\n    if (distance.get_distance(MM) > 100) and bool(checkVisited(angle + 90)):\n        # drive to the open space, and recursivly call the method again\n        drivetrain.drive_for(FORWARD, 250, MM)\n        solveMaze(angle + 90)\n\n    # Check is the maze has been solved\n    if down_eye.detect(RED):\n        return\n\n    # Check if the left path is availble\n    drivetrain.turn_to_heading(angle + 270, DEGREES)\n    if (distance.get_distance(MM) > 100) and bool(checkVisited(angle + 270)):\n        # drive to the open space, and recursivly call the method again\n        drivetrain.drive_for(FORWARD, 250, MM)\n        solveMaze(angle + 270)\n    \n    # Check is the maze has been solved\n    if down_eye.detect(RED):\n        return\n    \n    # if none are available, go back to where you came from\n    drivetrain.turn_to_heading(angle + 180, DEGREES)\n    drivetrain.drive_for(FORWARD, 250, MM)\n    \n\ndef main():    \n    # Clear the output\n    brain.clear()\n\n    # Initilize to full speed so the maze is solved as fast as possible\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    # Reset the timer to get an acurate time measurment\n    brain.timer_reset()\n\n    # Initilize the visited array\n    initilizeMaze()\n\n    # Recusivly solve the maze\n    solveMaze()\n\n    # Output the results\n    brain.print(\"Time it took to solve: \")\n    brain.print(brain.timer_time(SECONDS))\n    brain.print(\" seconds\")\n\n# VR threads â€” Do not delete\nvr_thread(main())\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":"","playground":"WallMaze"}